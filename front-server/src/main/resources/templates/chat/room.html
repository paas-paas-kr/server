<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 상담 - 다문화 가정 상담 서비스</title>
    <link rel="stylesheet" th:href="@{/css/style.css}">
</head>
<body>
    <div class="chat-container">
        <!-- 채팅 헤더 -->
        <div class="chat-header">
            <button class="back-btn" onclick="goBack()">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 12H5M12 19l-7-7 7-7"/>
                </svg>
            </button>
            <div class="chat-title" id="chatTitle">AI 상담사</div>
        </div>

        <!-- 메시지 영역 -->
        <div class="chat-messages" id="chatMessages">
            <!-- 메시지가 여기에 동적으로 추가됩니다 -->
        </div>

        <!-- 입력 영역 -->
        <div class="chat-input-container">
            <form class="chat-input-form" onsubmit="sendMessage(event)">
                <button type="button" class="voice-btn" id="voiceBtn" onclick="toggleVoiceRecording()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                </button>
                <textarea
                    class="chat-input"
                    id="messageInput"
                    placeholder="메시지를 입력하세요..."
                    rows="1"
                    onkeydown="handleKeyDown(event)"
                ></textarea>
                <button type="submit" class="send-btn" id="sendBtn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                </button>
            </form>
        </div>
    </div>

    <script src="/js/config.js"></script>
    <script src="/js/i18n.js"></script>
    <script th:inline="javascript">
        const threadId = /*[[${threadId}]]*/ '';
        let currentThread = null;
        let ws = null;
        let audioWs = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;

        // WebSocket 연결
        function connectWebSocket() {
            const token = localStorage.getItem('accessToken');
            if (!token) {
                console.error('No access token found');
                addMessage('ai', '로그인이 필요합니다. 다시 로그인해주세요.');
                return;
            }

            // WebSocket URL 생성
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // 프로덕션: 현재 도메인 사용, 로컬: API_BASE_URL 사용
            let wsHost;
            if (window.API_BASE_URL && window.API_BASE_URL !== '') {
                wsHost = new URL(window.API_BASE_URL).host;
            } else {
                wsHost = window.location.host;
            }
            const wsUrl = `${wsProtocol}//${wsHost}/ws/chat?token=${token}`;

            console.log('Connecting to WebSocket:', wsUrl);

            try {
                ws = new WebSocket(wsUrl);

                ws.onopen = function(event) {
                    console.log('WebSocket connected');
                    reconnectAttempts = 0;

                    // 연결 시작 메시지 전송
                    sendWebSocketMessage({
                        type: 'START',
                        text: '',
                        userId: 'user',
                        lang: window.i18n ? window.i18n.getLanguageCode(window.i18n.getCurrentLanguage()) : 'KOREAN',
                        roomId: threadId
                    });
                };

                ws.onmessage = function(event) {
                    console.log('WebSocket message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                };

                ws.onclose = function(event) {
                    console.log('WebSocket closed:', event.code, event.reason);

                    // 자동 재연결 시도
                    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        console.log(`Reconnecting... (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                        setTimeout(connectWebSocket, 2000 * reconnectAttempts);
                    } else {
                        addMessage('ai', '서버와의 연결이 끊어졌습니다. 페이지를 새로고침해주세요.');
                    }
                };
            } catch (error) {
                console.error('Error creating WebSocket:', error);
            }
        }

        // WebSocket으로 메시지 전송
        function sendWebSocketMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                console.log('Message sent:', message);
            } else {
                console.error('WebSocket is not connected');
            }
        }

        // WebSocket 메시지 처리
        function handleWebSocketMessage(data) {
            console.log('Handling message:', data);

            if (data.type === 'nlp-stream') {
                // NLP 스트리밍 응답 처리
                if (data.event === 'original_text') {
                    // 최종 번역된 AI 응답
                    const aiText = data.data?.text || '';
                    if (aiText) {
                        updateOrAddAIMessage(aiText);
                    }
                } else if (data.event === 'delta') {
                    // 스트리밍 중간 텍스트 (선택적 표시)
                    const delta = data.data?.delta || '';
                    if (delta) {
                        appendToLastAIMessage(delta);
                    }
                }
            } else if (data.type === 'CHAT' || data.type === 'TRANS') {
                // 일반 채팅 메시지 또는 번역 메시지
                const text = data.text || data.data?.text || '';
                if (text) {
                    updateOrAddAIMessage(text);
                }
            } else if (data.type === 'ERROR') {
                // 에러 메시지
                const errorText = data.text || '오류가 발생했습니다.';
                addMessage('ai', errorText);
            }
        }

        // AI 메시지 업데이트 또는 추가
        let lastAIMessageContent = '';
        function updateOrAddAIMessage(text) {
            if (lastAIMessageContent === text) {
                return; // 중복 방지
            }

            lastAIMessageContent = text;

            // 마지막 메시지가 AI 메시지인지 확인
            if (currentThread.messages.length > 0) {
                const lastMessage = currentThread.messages[currentThread.messages.length - 1];
                if (lastMessage.role === 'ai' && !lastMessage.finalized) {
                    // 기존 AI 메시지 업데이트
                    lastMessage.content = text;
                    lastMessage.finalized = true;
                } else {
                    // 새 AI 메시지 추가
                    addMessage('ai', text);
                }
            } else {
                // 새 AI 메시지 추가
                addMessage('ai', text);
            }
            saveThread();
            renderMessages();
        }

        // 마지막 AI 메시지에 텍스트 추가 (스트리밍용)
        function appendToLastAIMessage(delta) {
            if (currentThread.messages.length > 0) {
                const lastMessage = currentThread.messages[currentThread.messages.length - 1];
                if (lastMessage.role === 'ai' && !lastMessage.finalized) {
                    lastMessage.content += delta;
                    renderMessages();
                    return;
                }
            }

            // 마지막 메시지가 AI가 아니면 새로 추가
            const newMessage = {
                role: 'ai',
                content: delta,
                timestamp: new Date().toISOString(),
                finalized: false
            };
            currentThread.messages.push(newMessage);
            renderMessages();
        }

        // 서버에서 채팅 메시지 가져오기
        async function getChatMessages(roomId) {
            try {
                const token = localStorage.getItem('accessToken');
                if (!token) {
                    console.error('No access token found');
                    return [];
                }

                const url = `${window.API_BASE_URL}/api/chat/conversations/room/${roomId}/messages?size=50`;
                console.log('Fetching messages from:', url);

                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.error('Failed to fetch messages:', response.status);
                    return [];
                }

                const data = await response.json();
                console.log('Messages received:', data);

                const messages = data.items || [];

                // 서버 데이터를 프론트 형식으로 변환 (역순 정렬)
                return messages.reverse().map(msg => ({
                    role: msg.isUserMessage ? 'user' : 'ai',
                    content: msg.content || msg.text,
                    timestamp: msg.createdAt
                }));
            } catch (error) {
                console.error('Error fetching messages:', error);
                return [];
            }
        }

        // 스레드 데이터 로드
        async function loadThread() {
            currentThread = {
                id: threadId,
                title: '채팅',
                lastMessage: '',
                messageCount: 0,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                messages: []
            };

            // 서버에서 메시지 로드
            currentThread.messages = await getChatMessages(threadId);

            document.getElementById('chatTitle').textContent = currentThread.title;
            renderMessages();
        }

        // 메시지 렌더링
        function renderMessages() {
            const messagesContainer = document.getElementById('chatMessages');

            if (!currentThread.messages || currentThread.messages.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="empty-state">
                        <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        <h3 class="empty-title">대화를 시작해보세요</h3>
                        <p class="empty-text">궁금한 것을 물어보세요</p>
                    </div>
                `;
                return;
            }

            messagesContainer.innerHTML = currentThread.messages.map(msg => `
                <div class="message ${msg.role}">
                    ${msg.role === 'ai' ? '<div class="message-avatar">AI</div>' : ''}
                    <div class="message-content">${escapeHtml(msg.content)}</div>
                    ${msg.role === 'user' ? '<div class="message-avatar">나</div>' : ''}
                </div>
            `).join('');

            // 스크롤을 맨 아래로
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
        }

        // 메시지 전송
        async function sendMessage(event) {
            event.preventDefault();

            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message) return;

            // WebSocket 연결 확인
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('ai', '서버와 연결되어 있지 않습니다. 페이지를 새로고침해주세요.');
                return;
            }

            // 사용자 메시지 추가
            addMessage('user', message);
            input.value = '';

            // 입력 필드 높이 초기화
            input.style.height = 'auto';

            // 로딩 표시
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<div class="spinner"></div>';

            try {
                // WebSocket으로 메시지 전송
                sendWebSocketMessage({
                    type: 'CHAT',
                    text: message,
                    userId: 'user',
                    lang: window.i18n ? window.i18n.getLanguageCode(window.i18n.getCurrentLanguage()) : 'KOREAN',
                    roomId: threadId
                });

                // 임시 AI 메시지 추가 (응답 대기 중)
                lastAIMessageContent = '';
                const tempMessage = {
                    role: 'ai',
                    content: '...',
                    timestamp: new Date().toISOString(),
                    finalized: false
                };
                currentThread.messages.push(tempMessage);
                saveThread();
                renderMessages();
            } catch (error) {
                console.error('Error sending message:', error);
                addMessage('ai', '죄송합니다. 오류가 발생했습니다. 다시 시도해주세요.');
            } finally {
                sendBtn.disabled = false;
                sendBtn.innerHTML = `
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                    </svg>
                `;
            }
        }

        // 메시지 추가
        function addMessage(role, content) {
            if (!currentThread.messages) {
                currentThread.messages = [];
            }

            const message = {
                role: role,
                content: content,
                timestamp: new Date().toISOString()
            };

            currentThread.messages.push(message);
            currentThread.lastMessage = content.substring(0, 50);
            currentThread.messageCount = currentThread.messages.length;
            currentThread.updatedAt = new Date().toISOString();

            // 제목 자동 생성 (첫 메시지일 경우)
            if (currentThread.messages.length === 1 && role === 'user') {
                currentThread.title = content.substring(0, 30) + (content.length > 30 ? '...' : '');
                document.getElementById('chatTitle').textContent = currentThread.title;
            }

            renderMessages();
        }

        // 키 이벤트 처리
        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(event);
            }

            // 텍스트 영역 자동 높이 조절
            const textarea = event.target;
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        // HTML 이스케이프
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/\n/g, '<br>');
        }

        // 뒤로 가기
        function goBack() {
            window.location.href = '/chat';
        }

        // 오디오 WebSocket 연결
        function connectAudioWebSocket() {
            const token = localStorage.getItem('accessToken');
            if (!token) {
                console.error('No access token found');
                return null;
            }

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHost = window.API_BASE_URL ? new URL(window.API_BASE_URL).host : window.location.host;
            const wsUrl = `${wsProtocol}//${wsHost}/ws/audio?token=${token}`;

            console.log('Connecting to Audio WebSocket:', wsUrl);

            try {
                const audioSocket = new WebSocket(wsUrl);

                audioSocket.onopen = function(event) {
                    console.log('Audio WebSocket connected');
                };

                audioSocket.onmessage = function(event) {
                    console.log('Audio WebSocket message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        // STT 결과를 입력창에 표시
                        if (data.text) {
                            const input = document.getElementById('messageInput');
                            input.value = data.text;
                        }
                    } catch (error) {
                        console.error('Error parsing audio message:', error);
                    }
                };

                audioSocket.onerror = function(error) {
                    console.error('Audio WebSocket error:', error);
                };

                audioSocket.onclose = function(event) {
                    console.log('Audio WebSocket closed:', event.code, event.reason);
                };

                return audioSocket;
            } catch (error) {
                console.error('Error creating Audio WebSocket:', error);
                return null;
            }
        }

        // 음성 녹음 토글
        async function toggleVoiceRecording() {
            const voiceBtn = document.getElementById('voiceBtn');

            if (!isRecording) {
                // 녹음 시작
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    // Audio WebSocket 연결
                    audioWs = connectAudioWebSocket();
                    if (!audioWs) {
                        alert('음성 서버와 연결할 수 없습니다.');
                        return;
                    }

                    mediaRecorder.ondataavailable = function(event) {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                            // WebSocket으로 실시간 오디오 스트리밍
                            if (audioWs && audioWs.readyState === WebSocket.OPEN) {
                                audioWs.send(event.data);
                            }
                        }
                    };

                    mediaRecorder.onstop = function() {
                        console.log('Recording stopped');
                        // 스트림 종료
                        stream.getTracks().forEach(track => track.stop());

                        // Audio WebSocket 종료
                        if (audioWs) {
                            audioWs.close();
                            audioWs = null;
                        }
                    };

                    mediaRecorder.start(100); // 100ms마다 데이터 전송
                    isRecording = true;

                    // 버튼 스타일 변경
                    voiceBtn.style.backgroundColor = '#ef4444';
                    voiceBtn.style.color = 'white';
                    console.log('Recording started');
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('마이크 접근 권한이 필요합니다.');
                }
            } else {
                // 녹음 중지
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                    isRecording = false;

                    // 버튼 스타일 복원
                    voiceBtn.style.backgroundColor = '';
                    voiceBtn.style.color = '';
                    console.log('Recording stopped by user');
                }
            }
        }

        // 페이지 로드 시 스레드 로드 및 WebSocket 연결
        document.addEventListener('DOMContentLoaded', async function() {
            await loadThread();
            connectWebSocket();
        });

        // 페이지 종료 시 WebSocket 연결 해제
        window.addEventListener('beforeunload', function() {
            if (ws) {
                ws.close();
            }
            if (audioWs) {
                audioWs.close();
            }
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        });
    </script>
</body>
</html>
